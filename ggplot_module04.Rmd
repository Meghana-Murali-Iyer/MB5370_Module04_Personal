---
title: "Data visualisation using ggplot2 package"
author: "Meghana Iyer"
date: "2025-09-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse) #this is the parent package
```

## Database: mpg - Fuel economy data from 1999 to 2008 for 38 popular models of cars

### Aesthetic

The base layer is added by ggplot(). geom() function adds attributes with different properties onto top of the base layer. The visual property of the objects can be points, lines etc.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = class)) #Change point colour by class
```

Can we change point size by class?

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
#> Warning: Using size for a discrete variable is not advised. 
```

Can we change point transparency by class? Yes, we use the argument alpha= for this.\
This is very helpful for dense point clouds, where you want a reader to see that there are overlapping data points.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
#> Warning: Using alpha for a discrete variable is not advised.
```

Change point shape by class.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
#> Warning: Using the shape palette for more than 6 discrete variables is not advised
#> as it becomes difficult to discriminate.
```

We can set properties manually as well, using a number or a colour.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue") 
#all the points are blue in colour now
```

There are several aesthetics that can be set up manually - colour of point, size of point, shape of point etc

### Facet and panel plots

This allows you to develop **separate plots** for a range of reasons, most often to show a **subset** of your data. To subset/facet your plot using a single variable, you use facet_wrap().\
**\~** dictates which variable you want to subset your data with

```{r}
#Note: only use facet_wrap() for discrete variables.
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2) #making separate plots as a function of 'class'
```

If you want to use a combination of two variables to facet plots, use facet_grid(); separating the variables by a \~.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```

What if you do not want to facet in the rows or columns dimension? We use a .\~ before the faceting variable. This argument just places the plots next to one another.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(. ~cyl)
```

### Fitting simple lines

In ggplot2 we can use a variety of visual objects to represent our data points. 1. Display data as points

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

2.  Data a smooth line fir through the points

```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

***Quick recap***: A **geom** is an object that your plot uses to **represent** the data.\
As a budding scientist, it important to note what geom functions worked and what didn't, so use comments to better understand your mapping.

```{r}
ggplot(data = mpg) + 
#  geom_point(mapping = aes(x = displ, y = hwy)) # points horrible 
#  geom_smooth(mapping = aes(x = displ, y = hwy, colour = class)) # try smooth line, doesn't look legible
  geom_smooth(mapping = aes(x = displ, y = hwy, colour = drv, linetype = drv)) # based on drv variable, changing the type of line
```

How does grouping objects by categorical variables work in ggplot2?

```{r}
 ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv)) 
#The argument 'group=' is used for this

ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = FALSE,
  ) #Change the colour of each line based on drv value
```

Let's try combining both points and lines on the same graph

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = drv)) + 
  #first, put a layer of the points
  geom_smooth(mapping = aes(x = displ, y = hwy, colour = drv, linetype = drv)) 
  #second, add a layer of lines on top


#Efficiently, we can reduce the code chunk to this
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

```

Adding new features to the plot

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + #use mappings to display different aesthetics
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
  #specify different data for each layer, here we subset the data for plotting a line
```

## Database: diamonds - contains information about \~54,000 diamonds, including price, carat, colour, clarity and cut.

### Transformations and Stats

Simple bar plot to start our learning

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

Though we have just provided R with the x variable, it is outputting a plot. How is R calculating this? It is "binning" our data and then plotting our bin counts.

You can generally use ***geoms*** and ***stats*** interchangeably. For example, you can recreate the previous plot using stat_count() instead of geom_bar().

```{r}
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))

#1. If I try adding y variable as freq, R will pop an error
# ggplot(data = diamonds) + 
#  stat_count(mapping = aes(x = cut, y = frequency(x)))

#2. If I try doing the same this with geom_bar(), R will still pop an error? Why?
# ggplot(data = diamonds) + 
#  geom_bar(mapping = aes(x = cut, y = freqquency(x)))
    #This is because in both the cases, the parameters allows for either x or y aesthetic to be specified. 
```

Can we ***override*** a default stat (which is a count or a summary) to identity (which is the raw value of a variable)? Yes.

```{r}
#Example
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)
demo

ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")


#You can also override a default mapping from transformed variables to aesthetics
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))
#> Warning: `stat(prop)` was deprecated in ggplot2 3.4.0.

```

Can we plot ***statistical details*** using ggplot2?

```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  ) #fun is the function that is calculated by R, here it is a median.
```

### Aesthetic Adjustments

Three scenarios trying different aspects of aesthetics in ***ggplot2***

```{r}
#colour -> gives border colours for each of the bars in the plot
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))

#fill -> adds colour to the bars
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))

#Here, the fill argument is assigned to another variable in the 'diamonds' dataset called 'clarity'
#Notice how the stacking is done automatically. This is done behind the scenes with a position argument.
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity)) #Looks very messy

#Try altering transparency of bars in bar plot
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")

#To color the bar outlines with no fill color
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")

#Let's make stacked bar plots
#position = "fill" works like stacking, but makes each set of stacked bars the same height.
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")

#position = "dodge" places overlapping objects directly beside one another.
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")

#Using jitter for scatterplots
#position = "jitter" adds a small amount of random noise to each point to avoid overplotting when points overlap. This is useful for scatterplots but not barplots.
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")


```

### Grammar of Graphics 

ggplot(data = DATA) +\
GEOM_FUNCTION(\
mapping = aes(MAPPINGS),\
stat = STAT,\
position = POSITION\
) +\
FACET_FUNCTION\

## Database *mpg* -Using ggplot2 for communication 

### Labels

Using the labs() function

```{r}
#Scenario 1: title, subtitle, caption
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    title = "Fuel efficiency generally decreases with engine size",
    subtitle = "Two seaters (sports cars) are an exception because of their light weight",
    caption = "Data from fueleconomy.gov"
  )

#Scenario 2: axes labels and legend titles
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Engine displacement (L)",
    y = "Highway fuel economy (mpg)",
    colour = "Car type"
  )
```

### Annotations

What if you want to add text to the plot directly? Here we use geom_text() to add textual labels to our plots. This works similar to geom_point() but rather than a shape geometry it adds a label.

```{r}
best_in_class <- mpg %>%
  group_by(class) %>%
  filter(row_number(desc(hwy)) == 1)

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_text(aes(label = model), data = best_in_class)
#To avoid the labels from overlapping, we can use the argument nudge() within the function geom_text()
```

### Scales

We can change the default scales by tweaking the values in the scale parameters.

Observe how the readability of the graphs change with tweaks in the scale of x-axis.

```{r}
#Scenario 1
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_colour_discrete()

#Scenario 2
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous(limits = c(0, 15)) +
  scale_y_continuous() +
  scale_colour_discrete()

#Scenario 3
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous(limits = c(0, 10)) +
  scale_y_continuous() +
  scale_colour_discrete()

#Scenario 4
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous(limits = c(0, 8)) +
  scale_y_continuous() +
  scale_colour_discrete()
```

### Axis ticks

What if you want to change the ticks on the axes?

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5)) 
#Notice how the y-axis has breaks in multiples of 5, from 15 to 40.
#The funciton seq() outputs a sequence of number with the difference of a specified count.

```

### Legends and colour schemes

```{r}
base <- ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))

base + theme(legend.position = "left")
base + theme(legend.position = "top")
base + theme(legend.position = "bottom")
base + theme(legend.position = "right") # the default

#To suppress the display of the legend altogether use
# legend.position = 'none'
```

How can you change the colour scales?

```{r}
#Use colour palettes available on R
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv, shape = drv)) +
  scale_colour_brewer(palette = "Set1")

#Setting colours manually
presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id, colour = party)) +
    geom_point() +
    geom_segment(aes(xend = end, yend = id)) +
    scale_colour_manual(values = c(Republican = "red", Democratic = "blue"))
```

### Themes

You can customise the entire **theme** of your plot.

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_light()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_classic()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_dark()

## You can also set all the arguments for theme() yourself.
```
