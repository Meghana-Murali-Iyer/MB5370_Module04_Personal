---
title: "Data visualisation using ggplot2 package"
author: "Meghana Iyer"
date: "2025-09-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse) #this is the parent package
```

## Database: mpg - Fuel economy data from 1999 to 2008 for 38 popular models of cars

### Aesthetic

The base layer is added by ggplot(). geom() function adds attributes with different properties onto top of the base layer. The visual property of the objects can be points, lines etc.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = class)) #Change point colour by class
```

Can we change point size by class?

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
#> Warning: Using size for a discrete variable is not advised. 
```

Can we change point transparency by class? Yes, we use the argument alpha= for this.\
This is very helpful for dense point clouds, where you want a reader to see that there are overlapping data points.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
#> Warning: Using alpha for a discrete variable is not advised.
```

Change point shape by class.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
#> Warning: Using the shape palette for more than 6 discrete variables is not advised
#> as it becomes difficult to discriminate.
```

We can set properties manually as well, using a number or a colour.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue") 
#all the points are blue in colour now
```

There are several aesthetics that can be set up manually - colour of point, size of point, shape of point etc

### Facet and panel plots

This allows you to develop **separate plots** for a range of reasons, most often to show a **subset** of your data. To subset/facet your plot using a single variable, you use facet_wrap().\
**\~** dictates which variable you want to subset your data with

```{r}
#Note: only use facet_wrap() for discrete variables.
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2) #making separate plots as a function of 'class'
```

If you want to use a combination of two variables to facet plots, use facet_grid(); separating the variables by a \~.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```

What if you do not want to facet in the rows or columns dimension? We use a .\~ before the faceting variable. This argument just places the plots next to one another.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(. ~cyl)
```

### Fitting simple lines

In ggplot2 we can use a variety of visual objects to represent our data points. 1. Display data as points

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

2.  Data a smooth line fir through the points

```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

***Quick recap***: A **geom** is an object that your plot uses to **represent** the data.\
As a budding scientist, it important to note what geom functions worked and what didn't, so use comments to better understand your mapping.

```{r}
ggplot(data = mpg) + 
#  geom_point(mapping = aes(x = displ, y = hwy)) # points horrible 
#  geom_smooth(mapping = aes(x = displ, y = hwy, colour = class)) # try smooth line, doesn't look legible
  geom_smooth(mapping = aes(x = displ, y = hwy, colour = drv, linetype = drv)) # based on drv variable, changing the type of line
```

How does grouping objects by categorical variables work in ggplot2?

```{r}
 ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv)) 
#The argument 'group=' is used for this

ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = FALSE,
  ) #Change the colour of each line based on drv value
```

Let's try combining both points and lines on the same graph

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = drv)) + 
  #first, put a layer of the points
  geom_smooth(mapping = aes(x = displ, y = hwy, colour = drv, linetype = drv)) 
  #second, add a layer of lines on top


#Efficiently, we can reduce the code chunk to this
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

```

Adding new features to the plot

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + #use mappings to display different aesthetics
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
  #specify different data for each layer, here we subset the data for plotting a line
```

## Database: diamonds - contains information about \~54,000 diamonds, including price, carat, colour, clarity and cut.

### Transformations and Stats

Simple bar plot to start our learning

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

Though we have just provided R with the x variable, it is outputting a plot. How is R calculating this? It is "binning" our data and then plotting our bin counts.

You can generally use ***geoms*** and ***stats*** interchangeably. For example, you can recreate the previous plot using stat_count() instead of geom_bar().

```{r}
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))

#1. If I try adding y variable as freq, R will pop an error
# ggplot(data = diamonds) + 
#  stat_count(mapping = aes(x = cut, y = frequency(x)))

#2. If I try doing the same this with geom_bar(), R will still pop an error? Why?
# ggplot(data = diamonds) + 
#  geom_bar(mapping = aes(x = cut, y = freqquency(x)))
    #This is because in both the cases, the parameters allows for either x or y aesthetic to be specified. 
```

Can we ***override*** a default stat (which is a count or a summary) to identity (which is the raw value of a variable)? Yes.

```{r}
#Example
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)
demo

ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")


#You can also override a default mapping from transformed variables to aesthetics
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))
#> Warning: `stat(prop)` was deprecated in ggplot2 3.4.0.

```

Can we plot ***statistical details*** using ggplot2?

```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  ) #fun is the function that is calculated by R, here it is a median.
```

### Aesthetic Adjustments

Three scenarios trying different aspects of aesthetics in ***ggplot2***

```{r}
#colour -> gives border colours for each of the bars in the plot
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))

#fill -> adds colour to the bars
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))

#Here, the fill argument is assigned to another variable in the 'diamonds' dataset called 'clarity'
#Notice how the stacking is done automatically. This is done behind the scenes with a position argument.
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity)) #Looks very messy

#Try altering transparency of bars in bar plot
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")

#To color the bar outlines with no fill color
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")

#Let's make stacked bar plots
#position = "fill" works like stacking, but makes each set of stacked bars the same height.
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")

#position = "dodge" places overlapping objects directly beside one another.
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")

#Using jitter for scatterplots
#position = "jitter" adds a small amount of random noise to each point to avoid overplotting when points overlap. This is useful for scatterplots but not barplots.
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")


```

### Grammar of Graphics

ggplot(data = DATA) +\
GEOM_FUNCTION(\
mapping = aes(MAPPINGS),\
stat = STAT,\
position = POSITION\
) +\
FACET_FUNCTION\

## Database *mpg* -Using ggplot2 for communication

### Labels

Using the labs() function

```{r}
#Scenario 1: title, subtitle, caption
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    title = "Fuel efficiency generally decreases with engine size",
    subtitle = "Two seaters (sports cars) are an exception because of their light weight",
    caption = "Data from fueleconomy.gov"
  )

#Scenario 2: axes labels and legend titles
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Engine displacement (L)",
    y = "Highway fuel economy (mpg)",
    colour = "Car type"
  )
```

### Annotations

What if you want to add text to the plot directly? Here we use geom_text() to add textual labels to our plots. This works similar to geom_point() but rather than a shape geometry it adds a label.

```{r}
best_in_class <- mpg %>%
  group_by(class) %>%
  filter(row_number(desc(hwy)) == 1)

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_text(aes(label = model), data = best_in_class)
#To avoid the labels from overlapping, we can use the argument nudge() within the function geom_text()
```

### Scales

We can change the default scales by tweaking the values in the scale parameters.

Observe how the readability of the graphs change with tweaks in the scale of x-axis.

```{r}
#Scenario 1
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_colour_discrete()

#Scenario 2
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous(limits = c(0, 15)) +
  scale_y_continuous() +
  scale_colour_discrete()

#Scenario 3
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous(limits = c(0, 10)) +
  scale_y_continuous() +
  scale_colour_discrete()

#Scenario 4
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous(limits = c(0, 8)) +
  scale_y_continuous() +
  scale_colour_discrete()
```

### Axis ticks

What if you want to change the ticks on the axes?

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5)) 
#Notice how the y-axis has breaks in multiples of 5, from 15 to 40.
#The funciton seq() outputs a sequence of number with the difference of a specified count.

```

### Legends and colour schemes

```{r}
base <- ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))

base + theme(legend.position = "left")
base + theme(legend.position = "top")
base + theme(legend.position = "bottom")
base + theme(legend.position = "right") # the default

#To suppress the display of the legend altogether use
# legend.position = 'none'
```

How can you change the colour scales?

```{r}
#Use colour palettes available on R
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv, shape = drv)) +
  scale_colour_brewer(palette = "Set1")

#Setting colours manually
presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id, colour = party)) +
    geom_point() +
    geom_segment(aes(xend = end, yend = id)) +
    scale_colour_manual(values = c(Republican = "red", Democratic = "blue"))
```

### Themes

You can customise the entire **theme** of your plot.

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_light()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_classic()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_dark()

## You can also set all the arguments for theme() yourself.
```

## Data wrangling in R

### Data tidying using tidyR

Let's begin by understanding what makes a tidy dataset and why you [*always*]{.underline} should strive to get your data into a tidy format. There are some rules to keep in mind while tidying datasets:

1.  Each [**variable**]{.underline} must have its own [**column**]{.underline}.

2.  Each [**observation**]{.underline} must have its own [**row**]{.underline}.

3.  Each [**value**]{.underline} must have its own [**cell**]{.underline}.

In todays workshop we’ll use both %\>%, and \|\>  which achieve the exact same thing (\|\> is brand new in base R, %\>% only works in tidyr and magrittr packages). %\>% is a pipe that is used when you intend to apply a function (right of a pipe) to the data (left of the pipe). The process is called 'piping'.

If encountered with data that does not confer to the above rules, we can correct that using the **pivot** function. In tidyr: pivot_longer() is used to lengthen data and pivot_wider() is used to widen data.

Let's work this out using the 'billboard' dataset.

```{r}
billboard
#in this tibble, the actual values i.e., wk1, wk2 etc. are column names --> cell values
## remember the rules: each row is an observation

billboard %>%
  pivot_longer(
    cols = starts_with("wk"), #specifies the columns you want to pivot
    names_to = "week", #this names the variables stored in the column names
    values_to = "rank", #this names the variable stored in the cell values that we names rank
    values_drop_na = TRUE #removes all the NAs in the dataset
  )
#week and rank are in quotes as they ar enew variables we are creating
```

Second example of pivoting

```{r}
df <- tribble(
  ~id,  ~bp1, ~bp2,
   "A",  100,  120,
   "B",  140,  115,
   "C",  120,  125
)

df %>%
  pivot_longer(
    cols = starts_with("bp"),
    names_to = "measurement",
    values_to = "value"
  )
```

How does widening work? You use this in the case where an observation is spread across two rows.

```{r}
cms_patient_experience %>%
  pivot_wider(
    id_cols = starts_with("org"), #specify which column has values that uniquely identify each row
    names_from = measure_cd,
    values_from = prf_rate
  )
```

Practice question for widening

```{r}
df <- tribble(
  ~id, ~measurement, ~value,
  "A",        "bp1",    100,
  "B",        "bp1",    140,
  "B",        "bp2",    115, 
  "A",        "bp2",    120,
  "A",        "bp3",    105
)
#first thing to notice is that there are duplicate rows

df %>%
  pivot_wider(
    names_from = measurement,
    values_from = value
  )
```

#### Exercise questions

1.   Why are pivot_longer() and pivot_wider() not perfectly symmetrical? Carefully consider the following example.

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2016, 2016),
  half  = c(   1,    2,     1,    2),
  return = c(1.88, 0.59, 0.92, 0.17)
)
stocks
stocks %>% 
  pivot_wider(names_from = year, values_from = return) %>% 
  pivot_longer(
    cols = c(`2015`, `2016`),
    names_to = "year",
    values_to = "return")

# Why not perfectly symmetrical?
##pivot_wider() and pivot_longer() are not perfectly symmetrical because when a variable is widened into column names, its type is lost (numeric years become character column names). When pivoting longer again, you only recover characters unless you explicitly coerce. The `names_ptypes` argument exists to enforce the intended type (e.g., double() for years), restoring consistency with the original data.
```

2.  Why does this code fail?

```{r}
# table4a %>% 
  # pivot_longer(c(1999, 2000), names_to = "year", values_to = "cases")

#> Error in `pivot_longer()`:
#> ! Can't subset columns past the end.
#> ℹ Locations 1999 and 2000 don't exist.
#> ℹ There are only 3 columns.

##The `cols` argument of pivot_longer() does not recognise the locations of the columns -- it is read as column numbers 1999 and 2000. This can be solved by using cols = c(`1999`, `2000`)

```

3.  Consider the sample tibble below. Do you need to make it wider or longer? What are the variables?

```{r}
preg <- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)

## There are two variables here -- sex and pregnancy status -> these should be the columns

preg_tidy <- preg %>%
  pivot_longer(
    cols = c(`male`, `female`),
    names_to = "sex",
    values_to = "count",
    values_drop_na = TRUE
  )
preg_tidy

#we can further tidy up the data by following this rule --> "If a variable takes two values, like pregnant and sex, it is often preferable to store them as logical vectors."
preg_tidy.2 <- preg_tidy %>%
  mutate(
    female = sex == "female",
    pregnant = pregnant == "yes"
  ) %>%
  select(pregnant, female, count)
preg_tidy.2
```

#### Implicit missing values

sometimes we need to have explicit missings, instead of implicit missings inorder to have something to work with. Let's work with an example here –

```{r}
stocks <- tibble(
  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr   = c(   1,    2,    3,    4,    2,    3,    4),
  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)

# Using pivot_wider() is one easy of doing this. we stretch out the dataframe to force the entry of missing values.
stocks %>%
  pivot_wider(
    names_from = qtr,
    values_from = price
  )
```
